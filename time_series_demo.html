<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>3D Printer Stream — Live Charts</title>
  <style>
    :root { color-scheme: dark; }
    body { font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif;
           margin: 0; padding: 16px; background:#0b0d12; color:#e7ecf3; }
    h1 { font-size: 1.25rem; margin: 0 0 12px; }
    .row { display: grid; grid-template-columns: repeat(auto-fit, minmax(280px, 1fr)); gap: 16px; margin-bottom: 16px; }
    .card { background:#121622; border:1px solid #1f2637; border-radius: 12px; padding:12px; }
    canvas { width: 100%; height: 260px; display:block; }
    .status { display:flex; gap:12px; align-items:center; margin: 8px 0 16px; }
    .pill { padding:4px 10px; border-radius:999px; font-size:12px; border:1px solid #2a334a; background:#161b28; }
    button { background:#1b2133; color:#e7ecf3; border:1px solid #2a334a; border-radius:8px; padding:6px 10px; cursor:pointer; }
    button:hover { background:#232b41; }
    code { background:#0e111a; border:1px solid #1f2637; padding:2px 6px; border-radius:6px; }
    footer { opacity: .7; font-size: 12px; margin-top: 10px; }
    .log { background:#0e111a; border:1px solid #1f2637; border-radius:12px; padding:12px; margin-top: 12px; }
    .log h2 { font-size: 1rem; margin: 0 0 8px; }
    .log ul { list-style: none; padding:0; margin:0; max-height: 220px; overflow:auto; }
    .log li { padding:8px; border-bottom:1px solid #1a2236; display:flex; gap:10px; align-items: baseline; }
    .sev { font-size: 11px; padding:2px 6px; border-radius:999px; border:1px solid #2a334a; }
    .sev.WARN { background:#3a2a1a; color:#ffb84d; border-color:#5a3a1a; }
    .sev.ALERT { background:#3a1a1a; color:#ff6b6b; border-color:#5a1a1a; }
    .ts { opacity:.7; font-size:12px; min-width: 72px; }
    /* Whiteboard panel */
    .whiteboard { background:#0e111a; border:1px solid #1f2637; border-radius:12px; padding:8px; margin-top:12px; }
    .whiteboardHdr { display:flex; align-items:center; justify-content:space-between; gap:8px; padding-bottom:6px; }
    .wbDivider { height:1px; background:#1f2637; border:0; margin:6px 0 8px; }
    .whiteboard h2 { font-size: 1rem; margin: 0; }
    .wbControls { display:flex; gap:6px; }
    .wbBtn { background:#1b2133; color:#e7ecf3; border:1px solid #2a334a; border-radius:6px; padding:4px 8px; font-size:12px; cursor:pointer; }
    .wbBtn:hover { background:#232b41; }
    .frameWrap { width:100%; height:160px; background:#0b0d12; border-radius:8px; overflow:auto; resize:vertical; border:0; display:flex; justify-content:center; }
    .whiteboard iframe, .whiteboard object { width:60%; height:100%; border:0; background:#0b0d12; border-radius:8px; display:block; }
    .aiBtn { margin-left:auto; background:#25304a; border:1px solid #2a334a; color:#cfe3ff; padding:2px 6px; font-size:11px; border-radius:6px; cursor:pointer; }
    .aiBtn:hover { background:#2d3957; }
  </style>
  <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.3/dist/chart.umd.min.js"></script>
  <!-- Optional config for API keys; create config.js with window.OPENAI_API_KEY = 'sk-...'; -->
  <script src="config.js"></script>
</head>
<body>
  <div class="card" id="contextInfo" style="margin-bottom:12px;">
    <h2>More info</h2>
    <p>
      I thank Dr. Yifeng Gao for the idea of "Time Series", which influenced this project. API key must be added in config.js
    </p>
  </div>
  <h1>3D Printer Stream — Live Charts</h1>
  <div class="status">
    <span class="pill" id="fps">0 fps</span>
    <button id="pauseBtn">Pause</button>
    <button id="resumeBtn">Resume</button>
    <button id="clearBtn">Clear</button>
  </div>

  <div class="whiteboard">
    <div class="whiteboardHdr">
      <h2>Whiteboard</h2>
      <div class="wbControls">
        <button class="wbBtn" id="wbShrink">Shrink</button>
        <button class="wbBtn" id="wbExpand">Expand</button>
      </div>
    </div>
    <div class="wbDivider"></div>
    <div class="frameWrap" id="whiteboardWrap">
      <object id="whiteboardPdf" data="Whiteboard 1.pdf" type="application/pdf" title="Whiteboard PDF">
        <p>Open <a href="Whiteboard 1.pdf" target="_blank" rel="noopener">Whiteboard 1.pdf</a></p>
      </object>
    </div>
  </div>

  <div id="chartsRows">
    <div class="row">
      <div class="card"><canvas id="nozzle"></canvas></div>
      <div class="card"><canvas id="bed"></canvas></div>
      <div class="card"><canvas id="flow"></canvas></div>
      <div class="card"><canvas id="speed"></canvas></div>
      <div class="card"><canvas id="vibration"></canvas></div>
      <div class="card"><canvas id="ambient"></canvas></div>
      <div class="card"><canvas id="motor_x"></canvas></div>
      <div class="card"><canvas id="motor_y"></canvas></div>
      <div class="card"><canvas id="motor_z"></canvas></div>
      <div class="card"><canvas id="layer_h"></canvas></div>
    </div>
  </div>

  <div class="log">
    <h2>Exigent data fluctuations</h2>
    <ul id="eventLog"></ul>
  </div>

  

  <footer>
    Open this page to see the locally simulated data and anomaly log. Colors and order correspond to the sticky notes in the PDF.
  </footer>

  <script>
    // ---- Chart helpers ----
    function makeChart(ctx, label, yTitle, suggestedMin=null, suggestedMax=null) {
      return new Chart(ctx, {
        type: 'line',
        data: { labels: [], datasets: [
          { label: label + ' — Current', data: [], spanGaps: true, borderWidth: 2, pointRadius: 0, tension: 0.15, fill: false },
          { label: label + ' — Previous', data: [], spanGaps: true, borderWidth: 2, pointRadius: 0, tension: 0.15, fill: false, borderDash: [6, 4] },
        ] },
        options: {
          animation: false,
          responsive: true,
          maintainAspectRatio: false,
          parsing: true,
          interaction: { intersect: false, mode: 'nearest' },
          plugins: {
            decimation: { enabled: true, algorithm: 'min-max' },
            legend: { labels: { color: '#cbd5e1' } },
            chartAreaBg: { color: '#11182712' },
          },
          scales: {
            x: { type: 'linear', grid: { display:false }, border:{ display:false }, ticks: { color: '#93a3b8', maxTicksLimit: 7 }, title: { display: true, text: 't (s)', color:'#93a3b8' } },
            y: { grid: { display:false }, border:{ display:false }, ticks: { color: '#93a3b8' }, title: { display: true, text: yTitle, color:'#93a3b8' } },
          }
        }
      });
    }

    const nozzleChart = makeChart(document.getElementById('nozzle'), 'Nozzle Temp (°C)', '°C');
    const bedChart    = makeChart(document.getElementById('bed'),    'Bed Temp (°C)',    '°C');
    const flowChart   = makeChart(document.getElementById('flow'),   'Extruder Flow (mm³/s)', 'mm³/s');
    const speedChart  = makeChart(document.getElementById('speed'),  'Print Speed (mm/s)', 'mm/s');
    const vibChart    = makeChart(document.getElementById('vibration'), 'Vibration RMS (g)', 'g');
    const ambChart    = makeChart(document.getElementById('ambient'),   'Ambient Temp (°C)', '°C');
    const mxChart     = makeChart(document.getElementById('motor_x'),   'Motor Current X (A)', 'A');
    const myChart     = makeChart(document.getElementById('motor_y'),   'Motor Current Y (A)', 'A');
    const mzChart     = makeChart(document.getElementById('motor_z'),   'Motor Current Z (A)', 'A');
    const layerChart  = makeChart(document.getElementById('layer_h'),   'Layer Height (mm)', 'mm');

    let paused = false;

    function clearChart(chart) {
      chart.data.labels.length = 0;
      if (chart.data.datasets && chart.data.datasets.length) {
        for (const ds of chart.data.datasets) ds.data.length = 0;
      }
      // Reset axis bounds so autoscale can re-establish them on new data
      if (chart.options && chart.options.scales) {
        if (chart.options.scales.x) { chart.options.scales.x.min = undefined; chart.options.scales.x.max = undefined; }
        if (chart.options.scales.y) { chart.options.scales.y.min = undefined; chart.options.scales.y.max = undefined; }
      }
      chart.update();
    }

    document.getElementById('pauseBtn').onclick = () => paused = true;
    document.getElementById('resumeBtn').onclick = () => paused = false;
    document.getElementById('clearBtn').onclick = () => {
      [nozzleChart, bedChart, flowChart, speedChart, vibChart, ambChart, mxChart, myChart, mzChart, layerChart].forEach(clearChart);
    };

    // ---- FPS meter ----
    let frames = 0;
    setInterval(() => {
      document.getElementById('fps').textContent = frames + ' fps';
      frames = 0;
    }, 1000);

    // ---- Chart area background plugin & color mapping ----
    const chartBgPlugin = {
      id: 'chartAreaBg',
      beforeDraw(chart, args, opts) {
        const {ctx, chartArea} = chart;
        if (!chartArea) return;
        const color = opts && opts.color ? opts.color : null;
        if (!color) return;
        ctx.save();
        ctx.fillStyle = color;
        ctx.fillRect(chartArea.left, chartArea.top, chartArea.right - chartArea.left, chartArea.bottom - chartArea.top);
        ctx.restore();
      }
    };
    Chart.register(chartBgPlugin);

    const SIGNAL_TO_CHART = {
      nozzle_temp_c: nozzleChart,
      bed_temp_c: bedChart,
      extruder_flow_mm3_s: flowChart,
      print_speed_mm_s: speedChart,
      vibration_rms_g: vibChart,
      ambient_temp_c: ambChart,
      motor_current_x_a: mxChart,
      motor_current_y_a: myChart,
      motor_current_z_a: mzChart,
      layer_height_mm: layerChart,
    };
    // ---- PDF-based (manual) color mapping ----
    // Set colors here to match sticky notes in Whiteboard 1.pdf. Example hex values below; adjust to your PDF.
    const COLOR_MAP = {
      // C7A3DA group
      nozzle_temp_c: '#C7A3DA',
      bed_temp_c: '#C7A3DA',
      // FCCD7A group
      extruder_flow_mm3_s: '#FCCD7A',
      print_speed_mm_s: '#FCCD7A',
      layer_height_mm: '#FCCD7A',
      // CBE59C group
      ambient_temp_c: '#CBE59C',
      vibration_rms_g: '#CBE59C',
      motor_current_x_a: '#CBE59C',
      motor_current_y_a: '#CBE59C',
      motor_current_z_a: '#CBE59C',
    };
    // Optional manual order to reflect PDF layout
    const ORDER = [
      // C7A3DA
      'nozzle_temp_c','bed_temp_c',
      // FCCD7A
      'extruder_flow_mm3_s','print_speed_mm_s','layer_height_mm',
      // CBE59C
      'ambient_temp_c','vibration_rms_g','motor_current_x_a','motor_current_y_a','motor_current_z_a'
    ];

    function hexToRgb(hex) {
      const h = hex.replace('#','');
      const full = h.length === 3 ? h.split('').map(c=>c+c).join('') : h;
      return [parseInt(full.slice(0,2),16), parseInt(full.slice(2,4),16), parseInt(full.slice(4,6),16)];
    }
    function blendColors(rgb1, rgb2, t) { return [
      Math.round(rgb1[0]*(1-t) + rgb2[0]*t),
      Math.round(rgb1[1]*(1-t) + rgb2[1]*t),
      Math.round(rgb1[2]*(1-t) + rgb2[2]*t),
    ]; }
    function lighten(rgb, t) { return blendColors(rgb, [255,255,255], t); }
    function rgbaString([r,g,b], a=0.14) { return `rgba(${r}, ${g}, ${b}, ${a})`; }
    const THEME_RGB = [0x1f, 0x26, 0x37];

    function applyColorsFromConfig() {
      const orderSignals = ORDER.length ? ORDER : Object.keys(SIGNAL_TO_CHART);
      const container = document.querySelector('#chartsRows .row');
      for (const sig of orderSignals) {
        const chart = SIGNAL_TO_CHART[sig];
        if (!chart) continue;
        const hex = COLOR_MAP[sig];
        if (!hex) continue;
        const base = hexToRgb(hex);
        // Use exact hex as the base color; derive layer shades from it
        const stickyOuter = rgbaString(base, 0.26);
        const lighterArea = rgbaString(lighten(base, 0.12), 0.16); // slightly lighter & less opaque
        const dataFill = rgbaString(lighten(base, 0.28), 0.30);    // reduce opacity so line pops
        const border = `rgb(${lighten(base, 0.55).join(',')})`;    // strong bright line for contrast
        // outer card
        const card = container.querySelector(`canvas[id]#${sigToId(sig)}`)?.parentElement;
        if (card) card.style.backgroundColor = stickyOuter;
        // inner chart area and dataset
        chart.options.plugins.chartAreaBg = { color: lighterArea };
        // Current line styling
        chart.data.datasets[0].fill = false;
        chart.data.datasets[0].backgroundColor = dataFill;
        chart.data.datasets[0].borderColor = border;
        chart.data.datasets[0].borderWidth = 2;
        // Previous (lag-1) line styling: slightly dimmer
        if (chart.data.datasets[1]) {
          const prevBorder = `rgba(${lighten(base, 0.35).join(',')}, 0.85)`;
          chart.data.datasets[1].fill = false;
          chart.data.datasets[1].backgroundColor = 'transparent';
          chart.data.datasets[1].borderColor = prevBorder;
          chart.data.datasets[1].borderWidth = 2;
          chart.data.datasets[1].borderDash = [6, 4];
        }
      }
      if (ORDER.length) reorderCharts(orderSignals);
      // update once
      nozzleChart.update('none'); bedChart.update('none'); flowChart.update('none'); speedChart.update('none');
      vibChart.update('none'); ambChart.update('none'); mxChart.update('none'); myChart.update('none'); mzChart.update('none'); layerChart.update('none');
    }

    function sigToId(sig) {
      return {
        nozzle_temp_c: 'nozzle',
        bed_temp_c: 'bed',
        extruder_flow_mm3_s: 'flow',
        print_speed_mm_s: 'speed',
        vibration_rms_g: 'vibration',
        ambient_temp_c: 'ambient',
        motor_current_x_a: 'motor_x',
        motor_current_y_a: 'motor_y',
        motor_current_z_a: 'motor_z',
        layer_height_mm: 'layer_h',
      }[sig] || '';
    }
    // On load: normalize, apply config colors, and start local simulation
    window.addEventListener('load', () => {
      normalizeChartLayout();
      applyColorsFromConfig();
      startLocalSimulation();
    });

    // Whiteboard shrink/expand controls
    function setWhiteboardSize(mode) {
      const wrap = document.getElementById('whiteboardWrap');
      if (!wrap) return;
      // default small 160; xlarge doubles a typical large (360*2=720)
      const h = mode === 'xlarge' ? 520 : 160;
      wrap.style.height = h + 'px';
    }
    document.getElementById('wbShrink').onclick = () => setWhiteboardSize('small');
    document.getElementById('wbExpand').onclick = () => setWhiteboardSize('xlarge');

    // Move all chart cards into a single grid container so we can reorder easily
    function normalizeChartLayout() {
      const rows = document.getElementById('chartsRows');
      if (!rows) return;
      // Already normalized
      if (rows.dataset.normalized === '1') return;
      rows.dataset.normalized = '1';
      // Nothing else to do since HTML now uses a single grid row with all cards
    }

    function reorderCharts(orderSignals) {
      const container = document.querySelector('#chartsRows .row');
      if (!container) return;
      const cardBySignal = {
        nozzle_temp_c: container.querySelector('#nozzle')?.parentElement,
        bed_temp_c: container.querySelector('#bed')?.parentElement,
        extruder_flow_mm3_s: container.querySelector('#flow')?.parentElement,
        print_speed_mm_s: container.querySelector('#speed')?.parentElement,
        vibration_rms_g: container.querySelector('#vibration')?.parentElement,
        ambient_temp_c: container.querySelector('#ambient')?.parentElement,
        motor_current_x_a: container.querySelector('#motor_x')?.parentElement,
        motor_current_y_a: container.querySelector('#motor_y')?.parentElement,
        motor_current_z_a: container.querySelector('#motor_z')?.parentElement,
        layer_height_mm: container.querySelector('#layer_h')?.parentElement,
      };
      const existing = Array.from(container.children);
      const orderedCards = [];
      const added = new Set();
      for (const sig of orderSignals) {
        const card = cardBySignal[sig];
        if (card && !added.has(card)) { orderedCards.push(card); added.add(card); }
      }
      // append any remaining in current order
      for (const card of existing) {
        if (!added.has(card)) { orderedCards.push(card); added.add(card); }
      }
      // Re-append in new order
      for (const card of orderedCards) container.appendChild(card);
    }

    // ---- Anomaly detection (EWMA + z-score) ----
    const ALPHA = 0.05, EPS = 1e-9, WARN_Z = 3.0, ALERT_Z = 4.5, RUNLEN_ALERT = 6;
    const CRIT_HOLD_MS = 2500; // sustained alert duration before stop
    const ALERT_SINCE = {}; // sig -> ms when alert state started
    let SIM_HALTED = false;
    const STATS = {};  // signal -> {mean, var}
    const RUNLEN = {}; // signal -> count
    const LAST_EMIT = {}; // key -> last ts (ms)
    const DEDUP_COOLDOWN_MS = 3000; // 3s
    const SAMPLE_STRIDE = 5; // check anomalies every Nth sample (~2Hz from 10Hz)
    let sampleIndex = 0;

    function updateStats(sig, x) {
      if (!STATS[sig]) STATS[sig] = { mean: null, var: null };
      const s = STATS[sig];
      if (s.mean === null) { s.mean = x; s.var = 0; return { mean: s.mean, var: s.var }; }
      const m_prev = s.mean;
      s.mean = ALPHA * x + (1 - ALPHA) * s.mean;
      const resid = x - m_prev;
      s.var = ALPHA * (resid * resid) + (1 - ALPHA) * (s.var ?? 0);
      return { mean: s.mean, var: s.var };
    }

    function zscore(x, mean, v) { return (x - (mean ?? 0)) / Math.sqrt((v ?? 0) + EPS); }

    function runlen(sig, z) {
      if (!RUNLEN[sig]) RUNLEN[sig] = 0;
      if (Math.abs(z) >= WARN_Z) RUNLEN[sig] += 1; else RUNLEN[sig] = 0;
      return RUNLEN[sig];
    }

    function emitEvent(event) {
      const log = document.getElementById('eventLog');
      const li = document.createElement('li');
      const badge = document.createElement('span');
      badge.className = 'sev ' + event.severity;
      badge.textContent = event.severity;
      const ts = document.createElement('span');
      ts.className = 'ts';
      ts.textContent = event.t_sec.toFixed(1) + 's';
      const text = document.createElement('div');
      text.innerHTML = `<strong>${event.signal}</strong> ${event.direction} z=${event.zscore.toFixed(2)}; value=${event.value.toFixed(3)}`;
      const btn = document.createElement('button');
      btn.className = 'aiBtn';
      btn.textContent = 'AI Diagnose';
      btn.onclick = async () => {
        btn.disabled = true; btn.textContent = 'Diagnosing…';
        const out = await aiDiagnose(event);
        btn.textContent = 'AI Diagnose'; btn.disabled = false;
        let box = li.querySelector('.aiAnswer');
        if (!box) { box = document.createElement('div'); box.className = 'aiAnswer'; box.style.marginTop = '6px'; box.style.opacity = '0.9'; li.appendChild(box); }
        box.textContent = out || 'No suggestion available.';
      };
      li.appendChild(badge); li.appendChild(ts); li.appendChild(text); li.appendChild(btn);
      log.insertBefore(li, log.firstChild);
      // limit log length
      while (log.children.length > 200) log.removeChild(log.lastChild);
    }

    function considerEvent(sig, t_sec, x, z) {
      const severity = (Math.abs(z) >= ALERT_Z || runlen(sig, z) >= RUNLEN_ALERT) ? 'ALERT'
                      : (Math.abs(z) >= WARN_Z ? 'WARN' : null);
      if (!severity) return;
      const key = `${severity}:${sig}:${z > 0 ? 'HIGH' : 'LOW'}`;
      const now = performance.now();
      const last = LAST_EMIT[key] || 0;
      if ((now - last) < DEDUP_COOLDOWN_MS) return; // subfrequent
      LAST_EMIT[key] = now;
      emitEvent({
        t_sec,
        severity,
        signal: sig,
        value: x,
        zscore: z,
        direction: z > 0 ? 'high' : 'low',
      });
      // Critical detection with hold time, then stop simulation
      if (severity === 'ALERT' && !SIM_HALTED) {
        if (!ALERT_SINCE[sig]) ALERT_SINCE[sig] = now;
        const held = now - ALERT_SINCE[sig];
        if (held >= CRIT_HOLD_MS) {
          emitEvent({ t_sec, severity: 'CRITICAL', signal: sig, value: x, zscore: z, direction: 'halt' });
          stopSimulation();
          SIM_HALTED = true;
        }
      } else if (severity === 'WARN') {
        ALERT_SINCE[sig] = 0;
      }
    }

    // Removed WebSocket support; running fully client-side with local simulation

    // ---- Local in-browser simulator (mirrors simulator.py) ----
    const TICK_HZ = 10;
    const DT = 1.0 / TICK_HZ;
    const BASE = {
      nozzle_temp_c: 205.0,
      bed_temp_c: 60.0,
      extruder_flow_mm3_s: 6.0,
      motor_current_x_a: 0.8,
      motor_current_y_a: 0.8,
      motor_current_z_a: 0.9,
      vibration_rms_g: 0.02,
      print_speed_mm_s: 50.0,
      layer_height_mm: 0.2,
      ambient_temp_c: 24.0,
    };
    const NOISE = {
      nozzle_temp_c: 0.4,
      bed_temp_c: 0.2,
      extruder_flow_mm3_s: 0.15,
      motor_current_x_a: 0.03,
      motor_current_y_a: 0.03,
      motor_current_z_a: 0.04,
      vibration_rms_g: 0.004,
      print_speed_mm_s: 0.8,
      layer_height_mm: 0.0,
      ambient_temp_c: 0.05,
    };
    function gauss() {
      // Box-Muller
      let u = 0, v = 0; while (u === 0) u = Math.random(); while (v === 0) v = Math.random();
      return Math.sqrt(-2.0 * Math.log(u)) * Math.cos(2.0 * Math.PI * v);
    }
    function tick(state, t) {
      const s = { ...state };
      for (const [k, base] of Object.entries(BASE)) {
        const sigma = NOISE[k];
        let wobble = 0.0;
        if (k === 'extruder_flow_mm3_s' || k === 'vibration_rms_g') {
          const f = (k === 'extruder_flow_mm3_s') ? 0.8 : 3.2;
          wobble = 0.03 * Math.sin(2 * Math.PI * f * t);
        }
        s[k] = base + gauss() * sigma + wobble;
      }
      const speed_factor = 1.0 + 0.004 * (s.print_speed_mm_s - BASE.print_speed_mm_s);
      s.motor_current_x_a *= speed_factor;
      s.motor_current_y_a *= speed_factor;
      s.vibration_rms_g   *= speed_factor;
      s.extruder_flow_mm3_s = Math.max(0.0, s.extruder_flow_mm3_s);
      s.vibration_rms_g = Math.max(0.0, s.vibration_rms_g);
      return s;
    }
    function applyFaults(t, s, active) {
      const st = { ...s };
      if (active.UNDER_EXTRUSION) {
        st.extruder_flow_mm3_s *= 0.7 + 0.05 * Math.sin(1.7 * t);
        st.motor_current_x_a   *= 1.06;
        st.vibration_rms_g     *= 1.3;
      }
      if (active.OVER_EXTRUSION) {
        st.extruder_flow_mm3_s *= 1.25;
        st.motor_current_x_a   *= 1.04;
      }
      if (active.NOZZLE_TEMP_DRIFT_DOWN) {
        st.nozzle_temp_c -= 0.05;
      }
      if (active.BED_TEMP_OSCILLATE) {
        st.bed_temp_c += 1.5 * Math.sin(2 * Math.PI * 0.1 * t);
      }
      if (active.Y_AXIS_STICK_SLIP) {
        st.motor_current_y_a *= 1.0 + 0.25 * Math.max(0, Math.sin(4.0 * t));
        st.vibration_rms_g   *= 1.0 + 0.6 * Math.max(0, Math.sin(4.0 * t - 0.8));
      }
      if (active.AMBIENT_BREEZE) {
        st.ambient_temp_c -= 0.02;
        st.nozzle_temp_c  -= 0.05;
        st.bed_temp_c     -= 0.03;
      }
      return st;
    }
    const faultSchedule = [
      [15, 30, ['UNDER_EXTRUSION']],
      [45, 65, ['BED_TEMP_OSCILLATE']],
      [75, 95, ['Y_AXIS_STICK_SLIP', 'AMBIENT_BREEZE']],
      [110, 130, ['NOZZLE_TEMP_DRIFT_DOWN']],
    ];
    function activeFaults(now_s) {
      const a = {};
      for (const [start, end, names] of faultSchedule) {
        if (start <= now_s && now_s <= end) {
          for (const n of names) a[n] = true;
        }
      }
      return a;
    }
    let simTimer = null, simStart = null, simState = { ...BASE };
    let lastFaultKey = '';
    let lastFaultEmitMs = 0;

    function faultSeverityTag(name) {
      // Map specific faults to severity for the log
      switch (name) {
        case 'UNDER_EXTRUSION':
        case 'NOZZLE_TEMP_DRIFT_DOWN':
        case 'Y_AXIS_STICK_SLIP':
          return 'ALERT';
        case 'BED_TEMP_OSCILLATE':
        case 'AMBIENT_BREEZE':
        default:
          return 'WARN';
      }
    }
    function emitFaultsLog(t, faults) {
      if (!faults.length) return;
      const now = performance.now();
      const key = faults.join(',');
      const changed = key !== lastFaultKey;
      const intervalDue = now - lastFaultEmitMs > 3000; // every ~3s while active
      if (!changed && !intervalDue) return;
      lastFaultKey = key;
      lastFaultEmitMs = now;
      // Emit one line per active fault for clarity
      for (const f of faults) {
        const sev = faultSeverityTag(f);
        emitEvent({
          t_sec: t,
          severity: sev,
          signal: f,
          value: 0,
          zscore: 0,
          direction: 'active',
        });
      }
    }
    function startLocalSimulation() {
      if (simTimer) return;
      simStart = performance.now() / 1000.0;
      simState = { ...BASE };
      simTimer = setInterval(() => {
        if (paused) return;
        const now = performance.now() / 1000.0;
        const t = now - simStart;
        // 1) baseline tick
        simState = tick(simState, t);
        // 2) apply faults
        const faults = activeFaults(t);
        simState = applyFaults(t, simState, faults);
        // 3) emit a record-like object
        const ts = new Date().toISOString().replace(/\.\d{3}Z$/, (m)=>m.slice(0,5)+'Z');
        const rec = {
          ts,
          t_sec: Math.round(t * 1000) / 1000,
          layer_index: Math.floor(t / 12),
          faults_active: Object.keys(faults).sort(),
          signals: Object.fromEntries(Object.entries(simState).map(([k,v]) => [k, Math.round(v*1e5)/1e5]))
        };
        // Feed charts and anomaly checker as if it came from WS
        handleRecord(rec);
        // Emit Exigent data fluctuation log entries aligned with the current faults
        emitFaultsLog(t, rec.faults_active);
      }, 1000 / TICK_HZ);
    }

    function stopSimulation() {
      if (simTimer) { clearInterval(simTimer); simTimer = null; }
    }

    const TIME_WINDOW_SEC = 15; // prune data older than this window
    const RECENT = [];
    function autoscale(chart) {
      const dsets = chart.data.datasets || [];
      if (!dsets.length || dsets[0].data.length < 2) return;
      const latest = dsets[0].data[dsets[0].data.length - 1];
      const latestT = latest?.x;
      if (Number.isFinite(latestT)) {
        chart.options.scales.x.min = latestT - TIME_WINDOW_SEC;
        chart.options.scales.x.max = latestT;
      }
      let lo = Infinity, hi = -Infinity;
      for (const ds of dsets) {
        const arr = ds.data;
        for (let i = 0; i < arr.length; i++) {
          const v = arr[i]?.y;
          if (v == null || Number.isNaN(v)) continue;
          if (v < lo) lo = v;
          if (v > hi) hi = v;
        }
      }
      if (!Number.isFinite(lo) || !Number.isFinite(hi)) return;
      const pad = (hi - lo) * 0.12 || Math.abs(hi || 1) * 0.05;
      chart.options.scales.y.min = lo - pad;
      chart.options.scales.y.max = hi + pad;
    }
    function handleRecord(rec) {
      const t = rec.t_sec ?? 0;
      const s = rec.signals ?? {};
      if (s.nozzle_temp_c !== undefined) pushPoint(nozzleChart, t, s.nozzle_temp_c);
      if (s.bed_temp_c    !== undefined) pushPoint(bedChart,    t, s.bed_temp_c);
      if (s.extruder_flow_mm3_s !== undefined) pushPoint(flowChart,   t, s.extruder_flow_mm3_s);
      if (s.print_speed_mm_s    !== undefined) pushPoint(speedChart,  t, s.print_speed_mm_s);
      if (s.vibration_rms_g     !== undefined) pushPoint(vibChart,    t, s.vibration_rms_g);
      if (s.ambient_temp_c      !== undefined) pushPoint(ambChart,    t, s.ambient_temp_c);
      if (s.motor_current_x_a   !== undefined) pushPoint(mxChart,     t, s.motor_current_x_a);
      if (s.motor_current_y_a   !== undefined) pushPoint(myChart,     t, s.motor_current_y_a);
      if (s.motor_current_z_a   !== undefined) pushPoint(mzChart,     t, s.motor_current_z_a);
      if (s.layer_height_mm     !== undefined) pushPoint(layerChart,  t, s.layer_height_mm);
      // keep a recent record buffer for AI context and pruning
      RECENT.push(rec);
      const cutoff = t - TIME_WINDOW_SEC;
      while (RECENT.length && (RECENT[0].t_sec ?? 0) < cutoff) RECENT.shift();
      frames++;
      // Subfrequent anomaly checks
      sampleIndex = (sampleIndex + 1) % SAMPLE_STRIDE;
      if (sampleIndex === 0) {
        for (const [sig, val] of Object.entries(s)) {
          const { mean, var: v } = updateStats(sig, Number(val));
          const z = zscore(Number(val), mean, v);
          considerEvent(sig, t, Number(val), z);
        }
      }
      requestAnimationFrame(() => {
        // autoscale all charts before draw
        autoscale(nozzleChart); autoscale(bedChart); autoscale(flowChart); autoscale(speedChart); autoscale(vibChart);
        autoscale(ambChart); autoscale(mxChart); autoscale(myChart); autoscale(mzChart); autoscale(layerChart);
        nozzleChart.update('none');
        bedChart.update('none');
        flowChart.update('none');
        speedChart.update('none');
        vibChart.update('none');
        ambChart.update('none');
        mxChart.update('none');
        myChart.update('none');
        mzChart.update('none');
        layerChart.update('none');
      });
    }

    // Prune old points beyond TIME_WINDOW_SEC for every chart to prevent lag
    function pruneChart(chart, t_now) {
      const cutoff = t_now - TIME_WINDOW_SEC;
      const dsets = chart.data.datasets || [];
      if (!dsets.length) return;
      // Shift until the first point is inside window
      while (dsets[0].data.length && (dsets[0].data[0]?.x ?? -Infinity) < cutoff) {
        if (chart.data.labels && chart.data.labels.length) chart.data.labels.shift();
        for (const ds of dsets) { if (ds.data.length) ds.data.shift(); }
      }
    }
    const oldPushPoint = pushPoint;
    function pushPoint(chart, t, y) {
      const dsets = chart.data.datasets || [];
      const last = (dsets[0] && dsets[0].data.length) ? dsets[0].data[dsets[0].data.length - 1] : null;
      const prevVal = last?.y ?? null;
      // labels are optional for linear x; keep them small or omit
      // chart.data.labels.push(t);
      if (dsets.length >= 2) {
        dsets[0].data.push({ x: t, y });
        dsets[1].data.push({ x: t, y: prevVal });
      } else if (dsets.length >= 1) {
        dsets[0].data.push({ x: t, y });
      }
      pruneChart(chart, t);
    }

    // ---- OpenAI integration ----
    async function aiDiagnose(event) {
      try {
        // Prefer config.js value if present
        let key = (typeof window !== 'undefined' && window.OPENAI_API_KEY) ? window.OPENAI_API_KEY : localStorage.getItem('OPENAI_API_KEY');
        if (!key) {
          key = prompt('Enter your OpenAI API key (stored locally)');
          if (key) localStorage.setItem('OPENAI_API_KEY', key);
        }
        if (!key) return 'Missing API key';
        const faultsNow = Object.keys(activeFaults(event.t_sec || 0));
        const recent = RECENT.slice(-30); // last ~3s at 10Hz
        const minimal = recent.map(r=>({t_sec:r.t_sec, faults:r.faults_active, s:r.signals}));
        const prompt = `You are a senior 3D printing diagnostics expert. Given a detected issue, reply ONLY with a short, actionable fix. No preludes, no explanations, no markdown, no numbering unless the fix requires ordered steps. Keep under 40 words.\n\nIssue:\nseverity=${event.severity}; signal=${event.signal}; direction=${event.direction}; value=${event.value?.toFixed?.(3) ?? event.value}; z=${event.zscore?.toFixed?.(2) ?? event.zscore};\nActiveFaultsNow=${faultsNow.join(',') || 'none'}\nRecentWindow=${JSON.stringify(minimal).slice(0, 2000)}`;
        const body = { model: 'gpt-4o-mini', messages: [{role:'user', content: prompt}], temperature: 0.2, max_tokens: 120 }; 
        const res = await fetch('https://api.openai.com/v1/chat/completions', {
          method: 'POST', headers: { 'Content-Type': 'application/json', 'Authorization': `Bearer ${key}` }, body: JSON.stringify(body)
        });
        if (!res.ok) return 'AI request failed';
        const data = await res.json();
        return data.choices?.[0]?.message?.content?.trim() || 'No suggestion';
      } catch (e) {
        return 'AI error';
      }
    }
  </script>
</body>
</html>
